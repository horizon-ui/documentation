{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport path from \"path\";\nimport execa from \"execa\";\nimport format from \"date-fns/format\";\nimport fromUnixTime from \"date-fns/fromUnixTime\";\nimport { addLeadingSlash, getEditUrl } from \"@docusaurus/utils\";\nimport { serialize } from \"next-mdx-remote/serialize\";\nimport matter from \"gray-matter\";\nimport slugger from \"github-slugger\";\nexport async function serializeMdx(source) {\n  const {\n    content,\n    data\n  } = matter(source);\n  const mdxSource = await serialize(content, {\n    // Optionally pass remark/rehype plugins\n    mdxOptions: {\n      remarkPlugins: [require(\"remark-autolink-headings\"), require(\"remark-emoji\"), require(\"remark-images\"), require(\"remark-slug\"), require(\"remark-toc\"), require(\"remark-unwrap-images\")]\n    },\n    scope: data\n  });\n  return {\n    source: mdxSource,\n    frontMatter: data\n  };\n}\nexport async function processFrontmatter(options) {\n  const {\n    path: mdxPath,\n    author,\n    tags = [],\n    baseEditUrl = null,\n    slug: _slug\n  } = options,\n        rest = _objectWithoutProperties(options, [\"path\", \"author\", \"tags\", \"baseEditUrl\", \"slug\"]); // read the file path\n\n\n  const filePath = path.join(process.cwd(), \"pages\", mdxPath); // get the last edited author and date\n\n  const lastEdited = await getLastEdited(filePath); // get headings\n\n  const headings = rest.mdxContent ? getTableOfContents(rest.mdxContent) : []; // get the edit url\n\n  const editUrl = getEditUrl(path.join(mdxPath), baseEditUrl); // get the slug\n\n  const slug = _slug || fileToPath(mdxPath);\n\n  const data = _objectSpread(_objectSpread({}, rest), {}, {\n    slug,\n    lastEdited,\n    headings,\n    editUrl,\n    author,\n    tags\n  });\n\n  return data;\n}\n\nfunction fileToPath(str) {\n  return addLeadingSlash(str.replace(\".mdx\", \"\"));\n} //see https://github.com/hashicorp/next-mdx-remote/issues/53#issuecomment-725906664\n\n\nexport function getTableOfContents(mdxContent) {\n  const regexp = new RegExp(/^(### |## )(.*)\\n/, \"gm\"); // @ts-ignore\n\n  const headings = [...mdxContent.matchAll(regexp)];\n  let tableOfContents = [];\n\n  if (headings.length) {\n    tableOfContents = headings.map(heading => {\n      const headingText = heading[2].trim();\n      const headingType = heading[1].trim() === \"##\" ? \"h2\" : \"h3\";\n      const headingLink = slugger.slug(headingText, false);\n      return {\n        text: headingText,\n        id: headingLink,\n        level: headingType\n      };\n    });\n  }\n\n  return tableOfContents;\n}\n/**\n * Format the last edited timestamp and author from git output\n */\n\nfunction getTimestampAndAuthor(str) {\n  if (!str) return null;\n  const GIT_COMMIT_TIMESTAMP_AUTHOR_REGEX = /^(\\d+), (.+)$/;\n  const temp = str.match(GIT_COMMIT_TIMESTAMP_AUTHOR_REGEX);\n  if (!temp || temp.length < 3) return null;\n  const [, timestamp, author] = temp;\n  const dateStr = fromUnixTime(+timestamp);\n  return {\n    date: format(dateStr, \"MMMM dd, yyyy\"),\n    author\n  };\n}\n/**\n * Gets the last edited timestamp and author from git\n * using `git log`\n *\n * %an = author name\n * %ct = committer date, UNIX timestamp\n *\n * @see https://git-scm.com/docs/git-log\n */\n\n\nasync function getLastEdited(filePath) {\n  try {\n    const {\n      stdout\n    } = await execa(\"git\", [\"log\", \"-1\", \"--format=%ct, %an\", filePath]);\n    return getTimestampAndAuthor(stdout);\n  } catch (error) {\n    console.error(error);\n    return null;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}